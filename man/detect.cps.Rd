% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/detect.cps.R
\name{detect.cps}
\alias{detect.cps}
\title{detect.cps}
\usage{
detect.cps(
  Y,
  mindist = 35,
  nruns = 50,
  nreps = 100,
  alpha = 0.05,
  rank = "optimal",
  algtype = "brunet"
)
}
\arguments{
\item{Y}{A numerical matrix representing the multivariate time series, with the columns representing its components.}

\item{mindist}{A positive integer, by default is set to 35. It is used to define the minimum distance acceptable between detected change-points.}

\item{nruns}{A positive integer, by default is set to 50. It is used to define the number of runs in the NMF function.}

\item{nreps}{A positive integer, by default is set to 100. It is used to define the number of resamplings in the bootstrap procedure.}

\item{alpha}{A character string or a positive real number with default value equal to 0.05. If alpha = a positive integer value, say 0.05, then it is
used to define the significance level for inference on the change points. If alpha = "p-value", then the p-value calculated for inference on the change
points is returned.}

\item{rank}{A character string or a positive integer, which defines the rank be used in the optimization procedure to detect the change points.
If rank = “optimal”, which is also the default value, then the optimal rank is used. If rank = a positive integer value, say 4, then a predetermined
rank is used.}

\item{algtype}{A character string, which defines the algorithm to be used in the NMF function. By default is set to “brunet” - please see the "Algorithms"
section for more information on the available algorithms.}
}
\value{
A list where:\cr
\code{$rank} is the rank used for change point detection \cr
\code{$change.points} is a table of the change points detected where column "T" is the time of the change point and "stat.test" is the result of the t-test\cr
\code{$compute.time} is the compute time for the algorithm\cr
}
\description{
This function takes a multivariate time series, \eqn{Y}, and returns the change points detected. Utilizes non-negative
factorization (NMF) to detect changes in clustering structure.
}
\section{Algorithms}{

All algorithms available are presented below, please note the "fabisearch" package builds upon the algorithms available in the "NMF" package
\insertCite{Gaujoux2010}{fabisearch}:\cr

\code{"brunet"} - This algorithm is based on Kullback-Leibler divergence, from \insertCite{Brunet2004a}{fabisearch}. It uses multiplicative updates from
\insertCite{NIPS2000_1861}{fabisearch} with some small enhancements.\cr

\code{"lee"} - This algorithm is based on Euclidian distances from \insertCite{NIPS2000_1861}{fabisearch}, and uses simple multiplicative updates.\cr

\code{"ls-nmf"} - This is the least-squares NMF method from \insertCite{Wang2006}{fabisearch}. This algorithm uses an altered version of the Euclidian
distance based, multiplicative updates from \insertCite{NIPS2000_1861}{fabisearch}. It incorporates weights on each entry of the target matrix.\cr

\code{"nsNMF"} - This is the nonsmooth NMF method from \insertCite{Pascual-Montano2006}{fabisearch}. This algorithm uses an altered version of the
Kullback-Leibler based, multiplicative updates from \insertCite{NIPS2000_1861}{fabisearch}. It includes an intermediate "smoothing" matrix, which is
intended to produce sparser factors.\cr

\code{"offset"} - This is the offset NMF method from \insertCite{Badea2008}{fabisearch}. This algorithm uses an altered version of the Euclidian
distance based, multiplicative updates from \insertCite{NIPS2000_1861}{fabisearch}. It incorporates an intercept which is intended to reflect a common
pattern or baseline amongst components.\cr

\code{"pe-nmf"} - This is the pattern-expression NMF from \insertCite{Zhang2008}{fabisearch}. This algorithm utilizes multiplicative updates to minimize
a Euclidian distance based objective function. It is further regularized such that the basis vectors effectively express patterns.\cr

\code{"snmf/r","snmf/l"} - This is the alternating least-squares (ALS) approach from \insertCite{10.1093/bioinformatics/btm134}{fabisearch}. It uses the
non-negative, least-squares algorithm from \insertCite{VanBenthem2004}{fabisearch} to alternatingly estimate the basis and coefficent matrices. It
utilizes an Euclidian distance based objective function, and is regularized to promote either sparse basis ("snmf/l") or coefficent ("snmf/r") matrices \cr
}

\examples{
## Estimating the change points for a multivariate dataset, Y, using the default settings
detect.cps(Y)

## Estimating the change points for a multivariate dataset, Y, with an alpha value of 0.05
detect.cps(Y, alpha = 0.05)

## Estimating the change points for a multivariate dataset, Y, with a prespecified rank of 6
detect.cps(Y, rank = 6)

## Estimating the change points for a multivariate dataset, Y, with non-default values
detect.cps(Y, mindist = 50, nruns = 100, nreps = 1000,
   alpha = 0.001, rank = 7, algtype = "ls-nmf")

## Example output from the detect.cps() function
$rank
[1] 2

$change.points
    T stat.test
1 130 0.2292454

$compute.time
Time difference of 1.655591 mins

}
\references{
"Factorized Binary Search: a novel technique for change point detection in multivariate high-dimensional time series networks", Ondrus et al
(2021), preprint.

\insertAllCited{}
}
\author{
Martin Ondrus, \email{mondrus@ualberta.ca}, Ivor Cribben, \email{cribben@ualberta.ca}
}
